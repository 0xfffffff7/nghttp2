

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>nghttp2.h &mdash; nghttp2 0.4.0-DEV documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'./',
        VERSION:'0.4.0-DEV',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  false
      };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
    <script type="text/javascript">
        jQuery(function () {
            SphinxRtdTheme.StickyNav.enable();
        });
    </script>
  

  
    <link rel="top" title="nghttp2 0.4.0-DEV documentation" href="index.html"/>
        <link rel="next" title="nghttp2ver.h" href="nghttp2ver.h.html"/>
        <link rel="prev" title="API Reference" href="apiref.html"/> 

  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> nghttp2</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="package_README.html">nghttp2 - HTTP/2 C Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#development-status">Development Status</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#public-test-server">Public Test Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#build-from-git">Build from git</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#building-documentation">Building documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#client-server-and-proxy-programs">Client, Server and Proxy programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#benchmarking-tool">Benchmarking tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#hpack-tools">HPACK tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_README.html#python-bindings">Python bindings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-client.html">Tutorial: HTTP/2 client</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial-client.html#libevent-client-c">libevent-client.c</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-server.html">Tutorial: HTTP/2 server</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial-server.html#libevent-server-c">libevent-server.c</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nghttpx-howto.html">nghttpx - HOW-TO</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#default-mode">Default mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#http-2-proxy-mode">HTTP/2 proxy mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#client-mode">Client mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#client-proxy-mode">Client proxy mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#http-2-bridge-mode">HTTP/2 bridge mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#disable-ssl-tls">Disable SSL/TLS</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#specifying-additional-ca-certificate">Specifying additional CA certificate</a></li>
<li class="toctree-l2"><a class="reference internal" href="nghttpx-howto.html#read-write-rate-limit">Read/write rate limit</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="apiref.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#includes">Includes</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#remarks">Remarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#enums">Enums</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#types-structs-unions-and-typedefs">Types (structs, unions and typedefs)</a></li>
<li class="toctree-l2"><a class="reference internal" href="apiref.html#functions">Functions</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">nghttp2.h</a></li>
<li class="toctree-l1"><a class="reference internal" href="nghttp2ver.h.html">nghttp2ver.h</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/tatsuhiro-t/nghttp2">Source</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/tatsuhiro-t/nghttp2/issues">Issues</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">nghttp2</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>nghttp2.h</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="nghttp2-h">
<h1>nghttp2.h<a class="headerlink" href="#nghttp2-h" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * nghttp2 - HTTP/2 C Library</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2013, 2014 Tatsuhiro Tsujikawa</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="cm"> * a copy of this software and associated documentation files (the</span>
<span class="cm"> * &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="cm"> * without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="cm"> * distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="cm"> * permit persons to whom the Software is furnished to do so, subject to</span>
<span class="cm"> * the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="cm"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="cm"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="cm"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef NGHTTP2_H</span>
<span class="cp">#define NGHTTP2_H</span>

<span class="cp">#ifdef  __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdint.h&gt;</span>
<span class="cp">#include &lt;sys/types.h&gt;</span>

<span class="cp">#include &lt;nghttp2/nghttp2ver.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol version identification string of this library</span>
<span class="cm"> * supports.  This identifier is used if HTTP/2 is used over TLS.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_VERSION_ID &quot;h2-12&quot;</span>
<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_PROTO_VERSION_ID`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_PROTO_VERSION_ID_LEN 5</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The protocol version identification string of this library</span>
<span class="cm"> * supports.  This identifier is used if HTTP/2 is used over cleartext</span>
<span class="cm"> * TCP.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID &quot;h2c-12&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLEARTEXT_PROTO_VERSION_ID`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLEARTEXT_PROTO_VERSION_ID_LEN 6</span>

<span class="k">struct</span> <span class="n">nghttp2_session</span><span class="p">;</span>
<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The primary structure to hold the resources needed for a HTTP/2</span>
<span class="cm"> * session.  The details of this structure are intentionally hidden</span>
<span class="cm"> * from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_session</span> <span class="n">nghttp2_session</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The age of :type:`nghttp2_info`</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_VERSION_AGE 1</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * This struct is what `nghttp2_version()` returns.  It holds</span>
<span class="cm"> * information about the particular nghttp2 version.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Age of this struct.  This instance of nghttp2 sets it to</span>
<span class="cm">   * :macro:`NGHTTP2_VERSION_AGE` but a future version may bump it and</span>
<span class="cm">   * add more struct fields at the bottom</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * the :macro:`NGHTTP2_VERSION_NUM` number (since age ==1)</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">version_num</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * points to the :macro:`NGHTTP2_VERSION` string (since age ==1)</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">version_str</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * points to the :macro:`NGHTTP2_PROTO_VERSION_ID` string this</span>
<span class="cm">   * instance implements (since age ==1)</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">proto_str</span><span class="p">;</span>
  <span class="cm">/* -------- the above fields all exist when age == 1 */</span>
<span class="p">}</span> <span class="n">nghttp2_info</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The default weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_DEFAULT_WEIGHT 16</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MAX_WEIGHT 256</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The minimum weight of stream dependency.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MIN_WEIGHT 1</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum window size</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MAX_WINDOW_SIZE ((int32_t)((1U &lt;&lt; 31) - 1))</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The initial window size for stream level flow control.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_WINDOW_SIZE ((1 &lt;&lt; 16) - 1)</span>
<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The initial window size for connection level flow control.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ((1 &lt;&lt; 16) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The maximum header table size.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_MAX_HEADER_TABLE_SIZE (1 &lt;&lt; 16)</span>


<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The client connection preface.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_PREFACE &quot;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLIENT_CONNECTION_PREFACE`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_PREFACE_LEN 24</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The client connection header.  This macro is obsoleted by</span>
<span class="cm"> * NGHTTP2_CLIENT_CONNECTION_PREFACE.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_HEADER NGHTTP2_CLIENT_CONNECTION_PREFACE</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> *</span>
<span class="cm"> * The length of :macro:`NGHTTP2_CLIENT_CONNECTION_HEADER`.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_CLIENT_CONNECTION_HEADER_LEN    \</span>
<span class="cp">  NGHTTP2_CLIENT_CONNECTION_PREFACE_LEN</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * Error codes used in this library.  The code range is [-999, -500],</span>
<span class="cm"> * inclusive. The following values are defined:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Invalid argument passed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_ARGUMENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">501</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The specified protocol version is not supported.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_UNSUPPORTED_VERSION</span> <span class="o">=</span> <span class="o">-</span><span class="mi">503</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Used as a return value from :type:`nghttp2_send_callback` and</span>
<span class="cm">   * :type:`nghttp2_recv_callback` to indicate that the operation</span>
<span class="cm">   * would block.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_WOULDBLOCK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">504</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * General protocol error</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PROTO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">505</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_FRAME</span> <span class="o">=</span> <span class="o">-</span><span class="mi">506</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The peer performed a shutdown on the connection.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_EOF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">507</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Used as a return value from</span>
<span class="cm">   * :func:`nghttp2_data_source_read_callback` to indicate that data</span>
<span class="cm">   * transfer is postponed.  See</span>
<span class="cm">   * :func:`nghttp2_data_source_read_callback` for details.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DEFERRED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">508</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Stream ID has reached the maximum value.  Therefore no stream ID</span>
<span class="cm">   * is available.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">509</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream is already closed; or the stream ID is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_CLOSED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">510</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * RST_STREAM has been added to the outbound queue.  The stream is</span>
<span class="cm">   * in closing state.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_CLOSING</span> <span class="o">=</span> <span class="o">-</span><span class="mi">511</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The transmission is not allowed for this stream (e.g., a frame</span>
<span class="cm">   * with END_STREAM flag set has already sent).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_STREAM_SHUT_WR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">512</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream ID is invalid.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STREAM_ID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">513</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The state of the stream is not valid (e.g., DATA cannot be sent</span>
<span class="cm">   * to the stream if response HEADERS has not been sent).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STREAM_STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">514</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Another DATA frame has already been deferred.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DEFERRED_DATA_EXIST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">515</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Starting new stream is not allowed (e.g., GOAWAY has been sent</span>
<span class="cm">   * and/or received).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_START_STREAM_NOT_ALLOWED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">516</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * GOAWAY has already been sent.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_GOAWAY_ALREADY_SENT</span> <span class="o">=</span> <span class="o">-</span><span class="mi">517</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The received frame contains the invalid header block (e.g., There</span>
<span class="cm">   * are duplicate header names; or the header names are not encoded</span>
<span class="cm">   * in US-ASCII character set and not lower cased; or the header name</span>
<span class="cm">   * is zero-length string; or the header value contains multiple</span>
<span class="cm">   * in-sequence NUL bytes).</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_HEADER_BLOCK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">518</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that the context is not suitable to perform the</span>
<span class="cm">   * requested operation.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INVALID_STATE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">519</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The gzip error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_GZIP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">520</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The user callback function failed due to the temporal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">521</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the frame is invalid, either too large or too small.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FRAME_SIZE_ERROR</span> <span class="o">=</span> <span class="o">-</span><span class="mi">522</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Header block inflate/deflate error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_HEADER_COMP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">523</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Flow control error</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FLOW_CONTROL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">524</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Insufficient buffer size given to function.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_INSUFF_BUFSIZE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">525</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback was paused by the application</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PAUSE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">526</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * There are too many in-flight SETTING frame and no more</span>
<span class="cm">   * transmission of SETTINGS is allowed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">527</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The server push is disabled.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_PUSH_DISABLED</span> <span class="o">=</span> <span class="o">-</span><span class="mi">528</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * DATA frame for a given stream has been already submitted and has</span>
<span class="cm">   * not been fully processed yet.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_DATA_EXIST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">529</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The errors &lt; :enum:`NGHTTP2_ERR_FATAL` mean that the library is</span>
<span class="cm">   * under unexpected condition and processing was terminated (e.g.,</span>
<span class="cm">   * out of memory).  If application receives this error code, it must</span>
<span class="cm">   * stop using that :type:`nghttp2_session` object and only allowed</span>
<span class="cm">   * operation for that object is deallocate it using</span>
<span class="cm">   * `nghttp2_session_del()`.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_FATAL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Out of memory.  This is a fatal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_NOMEM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">901</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The user callback function failed.  This is a fatal error.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ERR_CALLBACK_FAILURE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">902</span>
<span class="p">}</span> <span class="n">nghttp2_error</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">NGHTTP2_MSG_MORE</span>
<span class="p">}</span> <span class="n">nghttp2_io_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for header field name/value pair.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates that this name/value pair must not be indexed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NV_FLAG_NO_INDEX</span> <span class="o">=</span> <span class="mh">0x1</span>
<span class="p">}</span> <span class="n">nghttp2_nv_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The name/value pair, which mainly used to represent header fields.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The |name| byte string, which is not necessarily ``NULL``</span>
<span class="cm">   * terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The |value| byte string, which is not necessarily ``NULL``</span>
<span class="cm">   * terminated.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |name|.</span>
<span class="cm">   */</span>
  <span class="kt">uint16_t</span> <span class="n">namelen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the |value|.</span>
<span class="cm">   */</span>
  <span class="kt">uint16_t</span> <span class="n">valuelen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Bitwise OR of one or more of :type:`nghttp2_nv_flag`.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_nv</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> * The control frame types in HTTP/2.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The DATA frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HEADERS</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PRIORITY</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The RST_STREAM frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_RST_STREAM</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PUSH_PROMISE frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PUSH_PROMISE</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PING frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PING</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The GOAWAY frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_GOAWAY</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The WINDOW_UPDATE frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_WINDOW_UPDATE</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The CONTINUATION frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CONTINUATION</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The ALTSVC frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ALTSVC</span> <span class="o">=</span> <span class="mh">0x0a</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The BLOCKED frame.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_BLOCKED</span> <span class="o">=</span> <span class="mh">0x0b</span>
<span class="p">}</span> <span class="n">nghttp2_frame_type</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags for HTTP/2 frames.  This enum defines all flags for all</span>
<span class="cm"> * frames.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The END_STREAM flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_END_STREAM</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The END_HEADERS flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_END_HEADERS</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The ACK flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_ACK</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The END_SEGMENT flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_END_SEGMENT</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PAD_LOW flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_PAD_LOW</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PAD_HIGH flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_PAD_HIGH</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_PRIORITY</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * THE COMPRESSED flag.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLAG_COMPRESSED</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="p">}</span> <span class="n">nghttp2_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> * The SETTINGS ID.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_HEADER_TABLE_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_HEADER_TABLE_SIZE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_ENABLE_PUSH</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_ENABLE_PUSH</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_MAX_CONCURRENT_STREAMS</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_INITIAL_WINDOW_SIZE</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_COMPRESS_DATA</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_COMPRESS_DATA</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Maximum ID of :type:`nghttp2_settings_id`.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_MAX</span> <span class="o">=</span> <span class="mi">5</span>
<span class="p">}</span> <span class="n">nghttp2_settings_id</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @macro</span>
<span class="cm"> * Default maximum concurrent streams.</span>
<span class="cm"> */</span>
<span class="cp">#define NGHTTP2_INITIAL_MAX_CONCURRENT_STREAMS ((1U &lt;&lt; 31) - 1)</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> * The status codes for the RST_STREAM and GOAWAY frames.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No errors.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_NO_ERROR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * PROTOCOL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_PROTOCOL_ERROR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * INTERNAL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_INTERNAL_ERROR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * FLOW_CONTROL_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FLOW_CONTROL_ERROR</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * SETTINGS_TIMEOUT</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_SETTINGS_TIMEOUT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * STREAM_CLOSED</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_STREAM_CLOSED</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * FRAME_SIZE_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_FRAME_SIZE_ERROR</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * REFUSED_STREAM</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_REFUSED_STREAM</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * CANCEL</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CANCEL</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * COMPRESSION_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_COMPRESSION_ERROR</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * CONNECT_ERROR</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_CONNECT_ERROR</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * ENHANCE_YOUR_CALM</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_ENHANCE_YOUR_CALM</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * INADEQUATE_SECURITY</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_INADEQUATE_SECURITY</span> <span class="o">=</span> <span class="mi">12</span>
<span class="p">}</span> <span class="n">nghttp2_error_code</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> * The frame header.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The length field of this frame, excluding frame header.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream identifier (aka, stream ID)</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The type of this frame.  See `nghttp2_frame`.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The flags.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_frame_hd</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * @union</span>
<span class="cm"> *</span>
<span class="cm"> * This union represents the some kind of data source passed to</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The integer field, suitable for a file descriptor.</span>
<span class="cm">   */</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to an arbitrary object.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data_source</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The flags used to set in |data_flags| output parameter in</span>
<span class="cm"> * :type:`nghttp2_data_source_read_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * No flag set.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates EOF was sensed.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_EOF</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * Indicates data was compressed by application.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_DATA_FLAG_COMPRESSED</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="p">}</span> <span class="n">nghttp2_data_flag</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the library wants to read data from</span>
<span class="cm"> * the |source|.  The read data is sent in the stream |stream_id|.</span>
<span class="cm"> * The implementation of this function must read at most |length|</span>
<span class="cm"> * bytes of data from |source| (or possibly other places) and store</span>
<span class="cm"> * them in |buf| and return number of data stored in |buf|.  If EOF is</span>
<span class="cm"> * reached, set :enum:`NGHTTP2_DATA_FLAG_EOF` flag in |*data_flags|.</span>
<span class="cm"> *</span>
<span class="cm"> * To send compressed data payload without affecting content-length,</span>
<span class="cm"> * set :enum:`NGHTTP2_DATA_FLAG_COMPRESSED` flag in |*data_flags|.</span>
<span class="cm"> * Compression must be done by application prior to fill data in</span>
<span class="cm"> * |buf|.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application wants to postpone DATA frames (e.g.,</span>
<span class="cm"> * asynchronous I/O, or reading data blocks for long time), it is</span>
<span class="cm"> * achieved by returning :enum:`NGHTTP2_ERR_DEFERRED` without reading</span>
<span class="cm"> * any data in this invocation.  The library removes DATA frame from</span>
<span class="cm"> * the outgoing queue temporarily.  To move back deferred DATA frame</span>
<span class="cm"> * to outgoing queue, call `nghttp2_session_resume_data()`.  In case</span>
<span class="cm"> * of error, there are 2 choices. Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close the stream</span>
<span class="cm"> * by issuing RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.</span>
<span class="cm"> * Returning :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the</span>
<span class="cm"> * entire session failure.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_data_source_read_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
 <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data_flags</span><span class="p">,</span>
 <span class="n">nghttp2_data_source</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * This struct represents the data source and the way to read a chunk</span>
<span class="cm"> * of data from it.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The data source.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data_source</span> <span class="n">source</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The callback function to read a chunk of data from the |source|.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data_source_read_callback</span> <span class="n">read_callback</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data_provider</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The DATA frame.  The received data is delivered via</span>
<span class="cm"> * :type:`nghttp2_on_data_chunk_recv_callback`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_data</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @enum</span>
<span class="cm"> *</span>
<span class="cm"> * The category of HEADERS, which indicates the role of the frame.  In</span>
<span class="cm"> * HTTP/2 spec, request, response, push response and other arbitrary</span>
<span class="cm"> * headers (e.g., trailers) are all called just HEADERS.  To give the</span>
<span class="cm"> * application the role of incoming HEADERS frame, we define several</span>
<span class="cm"> * categories.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is opening new stream, which is analogous to</span>
<span class="cm">   * SYN_STREAM in SPDY.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_REQUEST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is the first response headers, which is</span>
<span class="cm">   * analogous to SYN_REPLY in SPDY.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_RESPONSE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame is the first headers sent against reserved</span>
<span class="cm">   * stream.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_PUSH_RESPONSE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame which does not apply for the above categories,</span>
<span class="cm">   * which is analogous to HEADERS in SPDY.</span>
<span class="cm">   */</span>
  <span class="n">NGHTTP2_HCAT_HEADERS</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">}</span> <span class="n">nghttp2_headers_category</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The structure to specify stream dependency.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The stream ID of the stream to depend on.  Specifying 0 makes</span>
<span class="cm">   * stream not depend any other stream.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The weight of this dependency.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">weight</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * nonzero means exclusive dependency</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">exclusive</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_priority_spec</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The HEADERS frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The priority specification</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority_spec</span> <span class="n">pri_spec</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The name/value pairs.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of name/value pairs in |nva|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The category of this HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_headers_category</span> <span class="n">cat</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_headers</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PRIORITY frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The priority specification.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority_spec</span> <span class="n">pri_spec</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_priority</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The RST_STREAM frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The error code.  See :type:`nghttp2_error_code`.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_rst_stream</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The SETTINGS ID/Value pair.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS ID.  See :type:`nghttp2_settings_id`.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">settings_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The value of this entry.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_settings_entry</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The SETTINGS frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of SETTINGS ID/Value pairs in |iv|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">niv</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The pointer to the array of SETTINGS ID/Value pair.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_settings</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PUSH_PROMISE frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of the padding in this frame.  This includes PAD_HIGH</span>
<span class="cm">   * and PAD_LOW.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">padlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The name/value pairs.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The number of name/value pairs in |nva|.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The promised stream ID</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">promised_stream_id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_push_promise</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The PING frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The opaque data</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="n">opaque_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">nghttp2_ping</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The GOAWAY frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The last stream stream ID.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">last_stream_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The error code.  See :type:`nghttp2_error_code`.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The additional debug data</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |opaque_data| member.</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">opaque_data_len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_goaway</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The WINDOW_UPDATE frame.  It has the following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The window size increment.</span>
<span class="cm">   */</span>
  <span class="kt">int32_t</span> <span class="n">window_size_increment</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_window_update</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The ALTSVC frame.  It has following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Protocol ID</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">protocol_id</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Host</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Origin</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">origin</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |protocol_id|</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">protocol_id_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |host|</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">host_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The length of |origin|</span>
<span class="cm">   */</span>
  <span class="kt">size_t</span> <span class="n">origin_len</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Max-Age</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">max_age</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Port</span>
<span class="cm">   */</span>
  <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_altsvc</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The BLOCKED frame.  It has following members:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_blocked</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @union</span>
<span class="cm"> *</span>
<span class="cm"> * This union includes all frames to pass them to various function</span>
<span class="cm"> * calls as nghttp2_frame type.  The CONTINUATION frame is omitted</span>
<span class="cm"> * from here because the library deals with it internally.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * The frame header, which is convenient to inspect frame header.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_frame_hd</span> <span class="n">hd</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The DATA frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_data</span> <span class="n">data</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The HEADERS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_headers</span> <span class="n">headers</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PRIORITY frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_priority</span> <span class="n">priority</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The RST_STREAM frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_rst_stream</span> <span class="n">rst_stream</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The SETTINGS frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_settings</span> <span class="n">settings</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PUSH_PROMISE frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_push_promise</span> <span class="n">push_promise</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The PING frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_ping</span> <span class="n">ping</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The GOAWAY frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_goaway</span> <span class="n">goaway</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The WINDOW_UPDATE frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_window_update</span> <span class="n">window_update</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The ALTSVC frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_altsvc</span> <span class="n">altsvc</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The BLOCKED frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_blocked</span> <span class="n">blocked</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_frame</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when |session| wants to send data to the</span>
<span class="cm"> * remote peer.  The implementation of this function must send at most</span>
<span class="cm"> * |length| bytes of data stored in |data|.  The |flags| is currently</span>
<span class="cm"> * not used and always 0. It must return the number of bytes sent if</span>
<span class="cm"> * it succeeds.  If it cannot send any single byte without blocking,</span>
<span class="cm"> * it must return :enum:`NGHTTP2_ERR_WOULDBLOCK`.  For other errors,</span>
<span class="cm"> * it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is required if the application uses</span>
<span class="cm"> * `nghttp2_session_send()` to send data to the remote endpoint.  If</span>
<span class="cm"> * the application uses solely `nghttp2_session_mem_send()` instead,</span>
<span class="cm"> * this callback function is unnecessary.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_send_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when |session| wants to receive data from</span>
<span class="cm"> * the remote peer.  The implementation of this function must read at</span>
<span class="cm"> * most |length| bytes of data and store it in |buf|.  The |flags| is</span>
<span class="cm"> * currently not used and always 0.  It must return the number of</span>
<span class="cm"> * bytes written in |buf| if it succeeds.  If it cannot read any</span>
<span class="cm"> * single byte without blocking, it must return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  If it gets EOF before it reads any</span>
<span class="cm"> * single byte, it must return :enum:`NGHTTP2_ERR_EOF`.  For other</span>
<span class="cm"> * errors, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> * Returning 0 is treated as :enum:`NGHTTP2_ERR_WOULDBLOCK`.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is required if the application uses</span>
<span class="cm"> * `nghttp2_session_recv()` to receive data from the remote endpoint.</span>
<span class="cm"> * If the application uses solely `nghttp2_session_mem_recv()`</span>
<span class="cm"> * instead, this callback function is unnecessary.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_recv_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
 <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked by `nghttp2_session_recv()` when a frame</span>
<span class="cm"> * is received.  The |user_data| pointer is the third argument passed</span>
<span class="cm"> * in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``</span>
<span class="cm"> * member of their data structure are always ``NULL`` and 0</span>
<span class="cm"> * respectively.  The header name/value pairs are emitted via</span>
<span class="cm"> * :type:`nghttp2_on_header_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * For HEADERS, PUSH_PROMISE and DATA frames, this callback may be</span>
<span class="cm"> * called after stream is closed (see</span>
<span class="cm"> * :type:`nghttp2_on_stream_close_callback`).  The application should</span>
<span class="cm"> * check that stream is still alive using its own stream management or</span>
<span class="cm"> * :func:`nghttp2_session_get_stream_user_data()`.</span>
<span class="cm"> *</span>
<span class="cm"> * Only HEADERS and DATA frame can signal the end of incoming data.</span>
<span class="cm"> * If ``frame-&gt;hd.flags &amp; NGHTTP2_FLAG_END_STREAM`` is nonzero, the</span>
<span class="cm"> * |frame| is the last frame from the remote peer in this stream.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero value is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_recv_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked by `nghttp2_session_recv()` when an</span>
<span class="cm"> * invalid non-DATA frame is received.  The |error_code| is one of the</span>
<span class="cm"> * :enum:`nghttp2_error_code` and indicates the error.  When this</span>
<span class="cm"> * callback function is invoked, the library automatically submits</span>
<span class="cm"> * either RST_STREAM or GOAWAY frame.  The |user_data| pointer is the</span>
<span class="cm"> * third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If frame is HEADERS or PUSH_PROMISE, the ``nva`` and ``nvlen``</span>
<span class="cm"> * member of their data structure are always ``NULL`` and 0</span>
<span class="cm"> * respectively.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_invalid_frame_recv_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
 <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a chunk of data in DATA frame is</span>
<span class="cm"> * received.  The |stream_id| is the stream ID this DATA frame belongs</span>
<span class="cm"> * to.  The |flags| is the flags of DATA frame which this data chunk</span>
<span class="cm"> * is contained.  ``(flags &amp; NGHTTP2_FLAG_END_STREAM) != 0`` does not</span>
<span class="cm"> * necessarily mean this chunk of data is the last one in the stream.</span>
<span class="cm"> * You should use :type:`nghttp2_on_frame_recv_callback` to know all</span>
<span class="cm"> * data frames are received.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application uses `nghttp2_session_mem_recv()`, it can return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`</span>
<span class="cm"> * return without processing further input bytes.  The memory by</span>
<span class="cm"> * pointed by the |data| is retained until</span>
<span class="cm"> * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.</span>
<span class="cm"> * The application must retain the input bytes which was used to</span>
<span class="cm"> * produce the |data| parameter, because it may refer to the memory</span>
<span class="cm"> * region included in the input bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_data_chunk_recv_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked before the non-DATA frame |frame| is</span>
<span class="cm"> * sent.  This may be useful, for example, to know the stream ID of</span>
<span class="cm"> * HEADERS and PUSH_PROMISE frame (see also</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()`), which is not assigned</span>
<span class="cm"> * when it was queued.  The |user_data| pointer is the third argument</span>
<span class="cm"> * passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_before_frame_send_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked after the frame |frame| is sent.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_send_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked after the non-DATA frame |frame| is not</span>
<span class="cm"> * sent because of the error.  The error is indicated by the</span>
<span class="cm"> * |lib_error_code|, which is one of the values defined in</span>
<span class="cm"> * :type:`nghttp2_error`.  The |user_data| pointer is the third</span>
<span class="cm"> * argument passed in to the call to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_frame_not_send_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">,</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the stream |stream_id| is closed.</span>
<span class="cm"> * The reason of closure is indicated by the |error_code|.  The</span>
<span class="cm"> * stream_user_data, which was specified in `nghttp2_submit_request()`</span>
<span class="cm"> * or `nghttp2_submit_headers()`, is still available in this function.</span>
<span class="cm"> * The |user_data| pointer is the third argument passed in to the call</span>
<span class="cm"> * to `nghttp2_session_client_new()` or</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is also called for a stream in reserved state.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_stream_close_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">,</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the received frame type is unknown.</span>
<span class="cm"> * The |head| is the pointer to the header of the received frame.  The</span>
<span class="cm"> * |headlen| is the length of the |head|.  According to the spec, the</span>
<span class="cm"> * |headlen| is always 8.  In other words, the |head| is the first 8</span>
<span class="cm"> * bytes of the received frame.  The |payload| is the pointer to the</span>
<span class="cm"> * data portion of the received frame.  The |payloadlen| is the length</span>
<span class="cm"> * of the |payload|.  This is the data after the length field.  The</span>
<span class="cm"> * |user_data| pointer is the third argument passed in to the call to</span>
<span class="cm"> * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * If nonzero is returned, it is treated as fatal error and</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_send()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_unknown_frame_recv_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">headlen</span><span class="p">,</span>
 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">payloadlen</span><span class="p">,</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the reception of header block in</span>
<span class="cm"> * HEADERS or PUSH_PROMISE is started.  Each header name/value pair</span>
<span class="cm"> * will be emitted by :type:`nghttp2_on_header_callback`.</span>
<span class="cm"> *</span>
<span class="cm"> * The ``frame-&gt;hd.flags`` may not have</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_HEADERS` flag set, which indicates that one</span>
<span class="cm"> * or more CONTINUATION frames are involved.  But the application does</span>
<span class="cm"> * not need to care about that because the header name/value pairs are</span>
<span class="cm"> * emitted transparently regardless of CONTINUATION frames.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If nonzero value other than</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned, it is treated as</span>
<span class="cm"> * if :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned.  If</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,</span>
<span class="cm"> * `nghttp2_session_mem_recv()` function will immediately return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_begin_headers_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when a header name/value pair is received</span>
<span class="cm"> * for the |frame|.  The |name| of length |namelen| is header name.</span>
<span class="cm"> * The |value| of length |valuelen| is header value.  The |flags| is</span>
<span class="cm"> * bitwise OR of one or more of :type:`nghttp2_nv_flag`.</span>
<span class="cm"> *</span>
<span class="cm"> * If :enum:`NGHTTP2_NV_FLAG_NO_INDEX` is set in |flags|, the receiver</span>
<span class="cm"> * must not index this name/value pair when forwarding it to the next</span>
<span class="cm"> * hop.</span>
<span class="cm"> *</span>
<span class="cm"> * When this callback is invoked, ``frame-&gt;hd.type`` is either</span>
<span class="cm"> * :enum:`NGHTTP2_HEADERS` or :enum:`NGHTTP2_PUSH_PROMISE`.  After all</span>
<span class="cm"> * header name/value pairs are processed with this callback, and no</span>
<span class="cm"> * error has been detected, :type:`nghttp2_on_frame_recv_callback`</span>
<span class="cm"> * will be invoked.  If there is an error in decompression,</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` for the |frame| will not be</span>
<span class="cm"> * invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * The |name| may be ``NULL`` if the |namelen| is 0.  The same thing</span>
<span class="cm"> * can be said about the |value|.</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that nghttp2 library does not perform any validity</span>
<span class="cm"> * check against the |name| and the |value|.  For example, the</span>
<span class="cm"> * |namelen| could be 0, and/or the |value| contains ``0x0a`` or</span>
<span class="cm"> * ``0x0d``.  The application must check them if it matters.  The</span>
<span class="cm"> * helper function `nghttp2_check_header_name()` and</span>
<span class="cm"> * `nghttp2_check_header_value()` provide simple validation against</span>
<span class="cm"> * HTTP2 header field construction rule.</span>
<span class="cm"> *</span>
<span class="cm"> * One more thing to note is that the |value| may contain ``NULL``</span>
<span class="cm"> * (``0x00``) characters.  It is used to concatenate header values</span>
<span class="cm"> * which share the same header field name.  The application should</span>
<span class="cm"> * split these values if it wants to get individual value.  This</span>
<span class="cm"> * concatenation is used in order to keep the ordering of headers.</span>
<span class="cm"> *</span>
<span class="cm"> * If the application uses `nghttp2_session_mem_recv()`, it can return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` to make `nghttp2_session_mem_recv()`</span>
<span class="cm"> * return without processing further input bytes.  The memory pointed</span>
<span class="cm"> * by |frame|, |name| and |value| parameters are retained until</span>
<span class="cm"> * `nghttp2_session_mem_recv()` or `nghttp2_session_recv()` is called.</span>
<span class="cm"> * The application must retain the input bytes which was used to</span>
<span class="cm"> * produce these parameters, because it may refer to the memory region</span>
<span class="cm"> * included in the input bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close</span>
<span class="cm"> * the stream by issuing RST_STREAM with</span>
<span class="cm"> * :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,</span>
<span class="cm"> * :type:`nghttp2_on_frame_recv_callback` will not be invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation of this function must return 0 if it succeeds.</span>
<span class="cm"> * It may return :enum:`NGHTTP2_ERR_PAUSE` or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  For other critical</span>
<span class="cm"> * failures, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If</span>
<span class="cm"> * the other nonzero value is returned, it is treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,</span>
<span class="cm"> * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions</span>
<span class="cm"> * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_on_header_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
 <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">namelen</span><span class="p">,</span>
 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">valuelen</span><span class="p">,</span>
 <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked when the library asks application how</span>
<span class="cm"> * many padding bytes are required for the transmission of the</span>
<span class="cm"> * |frame|.  The application must choose the total length of payload</span>
<span class="cm"> * including padded bytes in range [frame-&gt;hd.length, max_payloadlen],</span>
<span class="cm"> * inclusive.  Choosing number not in this range will be treated as</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  Returning</span>
<span class="cm"> * ``frame-&gt;hd.length`` means no padding is added.  Returning</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will make</span>
<span class="cm"> * `nghttp2_session_send()` function immediately return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_select_padding_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
 <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
 <span class="kt">size_t</span> <span class="n">max_payloadlen</span><span class="p">,</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @functypedef</span>
<span class="cm"> *</span>
<span class="cm"> * Callback function invoked to adjust priority value for request</span>
<span class="cm"> * HEADERS.  This callback is called only for request HEADERS (which</span>
<span class="cm"> * means, `frame-&gt;hd.type == NGHTTP2_HEADERS &amp;&amp; frame-&gt;headers.cat ==</span>
<span class="cm"> * NGHTTP2_HCAT_REQUEST` hold) and before</span>
<span class="cm"> * :type:`nghttp2_before_frame_send_callback()`.  The application can</span>
<span class="cm"> * adjust priority value |pri_spec|.  Initially, |pri_spec| is filled</span>
<span class="cm"> * with the current priority value, which is equal to</span>
<span class="cm"> * `frame-&gt;headers.pri_spec`.  If the application doesn&#39;t alter</span>
<span class="cm"> * priority value, just return 0 without updating |pri_spec|.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the application doesn&#39;t know stream ID when it submits</span>
<span class="cm"> * requests, it may not be able to add correct priority value to</span>
<span class="cm"> * HEADERS frame and forced to use follwing PRIORITY frame.  The</span>
<span class="cm"> * purpose of this callback is give the chance to the application to</span>
<span class="cm"> * adjust priority value with the latest information it has just</span>
<span class="cm"> * before transmission so that correct priority is included in HEADERS</span>
<span class="cm"> * frame and it doesn&#39;t have to send additional PRIORITY frame.</span>
<span class="cm"> *</span>
<span class="cm"> * Returning :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will make</span>
<span class="cm"> * `nghttp2_session_send()` function immediately return</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nghttp2_adjust_priority_callback</span><span class="p">)</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
 <span class="k">const</span> <span class="n">nghttp2_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
 <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
 <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Callback functions.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when the |session| wants to send data</span>
<span class="cm">   * to the remote peer.  This callback is not necessary if the</span>
<span class="cm">   * application uses solely `nghttp2_session_mem_send()` to serialize</span>
<span class="cm">   * data to transmit.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_send_callback</span> <span class="n">send_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when the |session| wants to receive</span>
<span class="cm">   * data from the remote peer.  This callback is not necessary if the</span>
<span class="cm">   * application uses solely `nghttp2_session_mem_recv()` to process</span>
<span class="cm">   * received data.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_recv_callback</span> <span class="n">recv_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked by `nghttp2_session_recv()` when a</span>
<span class="cm">   * frame is received.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_frame_recv_callback</span> <span class="n">on_frame_recv_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked by `nghttp2_session_recv()` when an</span>
<span class="cm">   * invalid non-DATA frame is received.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_invalid_frame_recv_callback</span> <span class="n">on_invalid_frame_recv_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when a chunk of data in DATA frame is</span>
<span class="cm">   * received.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_data_chunk_recv_callback</span> <span class="n">on_data_chunk_recv_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked before a non-DATA frame is sent.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_before_frame_send_callback</span> <span class="n">before_frame_send_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked after a frame is sent.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_frame_send_callback</span> <span class="n">on_frame_send_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * The callback function invoked when a non-DATA frame is not sent</span>
<span class="cm">   * because of an error.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_frame_not_send_callback</span> <span class="n">on_frame_not_send_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when the stream is closed.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_stream_close_callback</span> <span class="n">on_stream_close_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when the received frame type is</span>
<span class="cm">   * unknown.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_unknown_frame_recv_callback</span> <span class="n">on_unknown_frame_recv_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when the reception of header block in</span>
<span class="cm">   * HEADERS or PUSH_PROMISE is started.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_begin_headers_callback</span> <span class="n">on_begin_headers_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when a header name/value pair is</span>
<span class="cm">   * received.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_on_header_callback</span> <span class="n">on_header_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked when the library asks application how</span>
<span class="cm">   * many padding bytes are required for the transmission of the given</span>
<span class="cm">   * frame.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_select_padding_callback</span> <span class="n">select_padding_callback</span><span class="p">;</span>
  <span class="cm">/**</span>
<span class="cm">   * Callback function invoked to adjust priority value just before</span>
<span class="cm">   * request HEADERS is serialized to the wire format.</span>
<span class="cm">   */</span>
  <span class="n">nghttp2_adjust_priority_callback</span> <span class="n">adjust_priority_callback</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nghttp2_session_callbacks</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">nghttp2_option</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * Configuration options for :type:`nghttp2_session`.  The details of</span>
<span class="cm"> * this structure are intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_option</span> <span class="n">nghttp2_option</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*option_ptr| with default values.</span>
<span class="cm"> *</span>
<span class="cm"> * When the application finished using this object, it can use</span>
<span class="cm"> * `nghttp2_option_del()` to free its memory.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_option_new</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">**</span><span class="n">option_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |option|.  If |option| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_del</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option prevents the library from sending WINDOW_UPDATE for a</span>
<span class="cm"> * stream automatically.  If this option is set to nonzero, the</span>
<span class="cm"> * library won&#39;t send WINDOW_UPDATE for a stream and the application</span>
<span class="cm"> * is responsible for sending WINDOW_UPDATE using</span>
<span class="cm"> * `nghttp2_submit_window_update`.  By default, this option is set to</span>
<span class="cm"> * zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_set_no_auto_stream_window_update</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                     <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option prevents the library from sending WINDOW_UPDATE for a</span>
<span class="cm"> * connection automatically.  If this option is set to nonzero, the</span>
<span class="cm"> * library won&#39;t send WINDOW_UPDATE for a connection and the</span>
<span class="cm"> * application is responsible for sending WINDOW_UPDATE with stream ID</span>
<span class="cm"> * 0 using `nghttp2_submit_window_update`.  By default, this option is</span>
<span class="cm"> * set to zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_set_no_auto_connection_window_update</span>
<span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * This option sets the SETTINGS_MAX_CONCURRENT_STREAMS value of</span>
<span class="cm"> * remote endpoint as if it is received in SETTINGS frame.  Without</span>
<span class="cm"> * specifying this option, before the local endpoint receives</span>
<span class="cm"> * SETTINGS_MAX_CONCURRENT_STREAMS in SETTINGS frame from remote</span>
<span class="cm"> * endpoint, SETTINGS_MAX_CONCURRENT_STREAMS is unlimited.  This may</span>
<span class="cm"> * cause problem if local endpoint submits lots of requests initially</span>
<span class="cm"> * and sending them at once to the remote peer may lead to the</span>
<span class="cm"> * rejection of some requests.  Specifying this option to the sensible</span>
<span class="cm"> * value, say 100, may avoid this kind of issue. This value will be</span>
<span class="cm"> * overwritten if the local endpoint receives</span>
<span class="cm"> * SETTINGS_MAX_CONCURRENT_STREAMS from the remote endpoint.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_option_set_peer_max_concurrent_streams</span><span class="p">(</span><span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">,</span>
                                                    <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*session_ptr| for client use.  The all members of</span>
<span class="cm"> * |callbacks| are copied to |*session_ptr|.  Therefore |*session_ptr|</span>
<span class="cm"> * does not store |callbacks|.  The |user_data| is an arbitrary user</span>
<span class="cm"> * supplied data, which will be passed to the callback functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The :member:`nghttp2_session_callbacks.send_callback` must be</span>
<span class="cm"> * specified.  If the application code uses `nghttp2_session_recv()`,</span>
<span class="cm"> * the :member:`nghttp2_session_callbacks.recv_callback` must be</span>
<span class="cm"> * specified.  The other members of |callbacks| can be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_client_new</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |*session_ptr| for server use.  The all members of</span>
<span class="cm"> * |callbacks| are copied to |*session_ptr|. Therefore |*session_ptr|</span>
<span class="cm"> * does not store |callbacks|.  The |user_data| is an arbitrary user</span>
<span class="cm"> * supplied data, which will be passed to the callback functions.</span>
<span class="cm"> *</span>
<span class="cm"> * The :member:`nghttp2_session_callbacks.send_callback` must be</span>
<span class="cm"> * specified.  If the application code uses `nghttp2_session_recv()`,</span>
<span class="cm"> * the :member:`nghttp2_session_callbacks.recv_callback` must be</span>
<span class="cm"> * specified.  The other members of |callbacks| can be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_server_new</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                               <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_client_new()`, but with additional options</span>
<span class="cm"> * specified in the |option|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |option| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_client_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |option|.  The application is</span>
<span class="cm"> * responsible for freeing |option| if it finishes using the object.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |option| after this function</span>
<span class="cm"> * returns.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_client_new2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Like `nghttp2_session_server_new()`, but with additional options</span>
<span class="cm"> * specified in the |option|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |option| can be ``NULL`` and the call is equivalent to</span>
<span class="cm"> * `nghttp2_session_server_new()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership |option|.  The application is</span>
<span class="cm"> * responsible for freeing |option| if it finishes using the object.</span>
<span class="cm"> *</span>
<span class="cm"> * The library code does not refer to |option| after this function</span>
<span class="cm"> * returns.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_server_new2</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">**</span><span class="n">session_ptr</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_session_callbacks</span> <span class="o">*</span><span class="n">callbacks</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">user_data</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_option</span> <span class="o">*</span><span class="n">option</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees any resources allocated for |session|.  If |session| is</span>
<span class="cm"> * ``NULL``, this function does nothing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_session_del</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sends pending frames to the remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function retrieves the highest prioritized frame from the</span>
<span class="cm"> * outbound queue and sends it to the remote peer.  It does this as</span>
<span class="cm"> * many as possible until the user callback</span>
<span class="cm"> * :member:`nghttp2_session_callbacks.send_callback` returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK` or the outbound queue becomes empty.</span>
<span class="cm"> * This function calls several callback functions which are passed</span>
<span class="cm"> * when initializing the |session|.  Here is the simple time chart</span>
<span class="cm"> * which tells when each callback is invoked:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Get the next frame to send from outbound queue.</span>
<span class="cm"> * 2. Prepare transmission of the frame.</span>
<span class="cm"> * 3. If the control frame cannot be sent because some preconditions</span>
<span class="cm"> *    are not met (e.g., request HEADERS cannot be sent after GOAWAY),</span>
<span class="cm"> *    :member:`nghttp2_session_callbacks.on_frame_not_send_callback`</span>
<span class="cm"> *    is invoked.  Abort the following steps.</span>
<span class="cm"> * 4. If the frame is request HEADERS,</span>
<span class="cm"> *    :member:`nghttp2_session_callbacks.adjust_priority_callback` is</span>
<span class="cm"> *    invoked.</span>
<span class="cm"> * 5. If the frame is HEADERS, PUSH_PROMISE or DATA,</span>
<span class="cm"> *    :member:`nghttp2_session_callbacks.select_padding_callback` is</span>
<span class="cm"> *    invoked.</span>
<span class="cm"> * 6. If the frame is request HEADERS, the stream is opened here.</span>
<span class="cm"> * 7. :member:`nghttp2_session_callbacks.before_frame_send_callback` is</span>
<span class="cm"> *    invoked.</span>
<span class="cm"> * 8. :member:`nghttp2_session_callbacks.send_callback` is invoked one</span>
<span class="cm"> *    or more times to send the frame.</span>
<span class="cm"> * 9. :member:`nghttp2_session_callbacks.on_frame_send_callback` is</span>
<span class="cm"> *    invoked.</span>
<span class="cm"> * 10. If the transmission of the frame triggers closure of the stream,</span>
<span class="cm"> *     the stream is closed and</span>
<span class="cm"> *     :member:`nghttp2_session_callbacks.on_stream_close_callback` is</span>
<span class="cm"> *     invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_send</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the serialized data to send.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_send()` except that it</span>
<span class="cm"> * does not use :member:`nghttp2_session_callbacks.send_callback` to</span>
<span class="cm"> * transmit data.  Instead, it assigns the pointer to the serialized</span>
<span class="cm"> * data to the |*data_ptr| and returns its length.  The other</span>
<span class="cm"> * callbacks are called in the same way as they are in</span>
<span class="cm"> * `nghttp2_session_send()`.</span>
<span class="cm"> *</span>
<span class="cm"> * If no data is available to send, this function returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may not return all serialized data in one invocation.</span>
<span class="cm"> * To get all data, call this function repeatedly until it returns 0</span>
<span class="cm"> * or one of negative error codes.</span>
<span class="cm"> *</span>
<span class="cm"> * The assigned |*data_ptr| is valid until the next call of</span>
<span class="cm"> * `nghttp2_session_mem_send()` or `nghttp2_session_send()`.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must send all data before sending the next chunk of</span>
<span class="cm"> * data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the length of the data pointed by the</span>
<span class="cm"> * |*data_ptr| if it succeeds, or one of the following negative error</span>
<span class="cm"> * codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_session_mem_send</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">data_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Receives frames from the remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives as many frames as possible until the user</span>
<span class="cm"> * callback :member:`nghttp2_session_callbacks.recv_callback` returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  This function calls several</span>
<span class="cm"> * callback functions which are passed when initializing the</span>
<span class="cm"> * |session|.  Here is the simple time chart which tells when each</span>
<span class="cm"> * callback is invoked:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. :member:`nghttp2_session_callbacks.recv_callback` is invoked one</span>
<span class="cm"> *    or more times to receive frame header.</span>
<span class="cm"> * 2. If the frame is DATA frame:</span>
<span class="cm"> *</span>
<span class="cm"> *    1. :member:`nghttp2_session_callbacks.recv_callback` is invoked</span>
<span class="cm"> *       to receive DATA payload. For each chunk of data,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_data_chunk_recv_callback`</span>
<span class="cm"> *       is invoked.</span>
<span class="cm"> *    2. If one DATA frame is completely received,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_frame_recv_callback` is</span>
<span class="cm"> *       invoked.  If the reception of the frame triggers the</span>
<span class="cm"> *       closure of the stream,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_stream_close_callback`</span>
<span class="cm"> *       is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. If the frame is the control frame:</span>
<span class="cm"> *</span>
<span class="cm"> *    1. :member:`nghttp2_session_callbacks.recv_callback` is invoked</span>
<span class="cm"> *       one or more times to receive whole frame.</span>
<span class="cm"> *</span>
<span class="cm"> *    2. If the received frame is valid, then following actions are</span>
<span class="cm"> *       taken.  If the frame is either HEADERS or PUSH_PROMISE,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_begin_headers_callback`</span>
<span class="cm"> *       is invoked.  Then</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_header_callback` is</span>
<span class="cm"> *       invoked for each header name/value pair.  After all name/value</span>
<span class="cm"> *       pairs are emitted successfully,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_frame_recv_callback` is</span>
<span class="cm"> *       invoked.  For other frames,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_frame_recv_callback` is</span>
<span class="cm"> *       invoked.</span>
<span class="cm"> *       If the reception of the frame triggers the closure of the</span>
<span class="cm"> *       stream,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_stream_close_callback`</span>
<span class="cm"> *       is invoked.</span>
<span class="cm"> *    3. If the received frame is unpacked but is interpreted as</span>
<span class="cm"> *       invalid,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_invalid_frame_recv_callback`</span>
<span class="cm"> *       is invoked.</span>
<span class="cm"> *    4. If the received frame type is unknown,</span>
<span class="cm"> *       :member:`nghttp2_session_callbacks.on_unknown_frame_recv_callback`</span>
<span class="cm"> *       is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_EOF`</span>
<span class="cm"> *     The remote peer did shutdown on the connection.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_recv</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Processes data |in| as an input from the remote endpoint.  The</span>
<span class="cm"> * |inlen| indicates the number of bytes in the |in|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function behaves like `nghttp2_session_recv()` except that it</span>
<span class="cm"> * does not use :member:`nghttp2_session_callbacks.recv_callback` to</span>
<span class="cm"> * receive data; the |in| is the only data for the invocation of this</span>
<span class="cm"> * function.  If all bytes are processed, this function returns.  The</span>
<span class="cm"> * other callbacks are called in the same way as they are in</span>
<span class="cm"> * `nghttp2_session_recv()`.</span>
<span class="cm"> *</span>
<span class="cm"> * In the current implementation, this function always tries to</span>
<span class="cm"> * processes all input data unless either an error occurs or</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PAUSE` is returned from</span>
<span class="cm"> * :member:`nghttp2_session_callbacks.on_header_callback` or</span>
<span class="cm"> * :member:`nghttp2_session_callbacks.on_data_chunk_recv_callback`.</span>
<span class="cm"> * If :enum:`NGHTTP2_ERR_PAUSE` is used, the return value includes the</span>
<span class="cm"> * number of bytes which was used to produce the data or frame for the</span>
<span class="cm"> * callback.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of processed bytes, or one of the</span>
<span class="cm"> * following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`</span>
<span class="cm"> *     The callback function failed.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_session_mem_recv</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Puts back previously deferred DATA frame in the stream |stream_id|</span>
<span class="cm"> * to the outbound queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The stream does not exist; or no deferred data exist; or data</span>
<span class="cm"> *     was deferred by flow control.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_resume_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero value if |session| wants to receive data from the</span>
<span class="cm"> * remote peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0, the application should</span>
<span class="cm"> * drop the connection.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_want_read</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero value if |session| wants to send data to the remote</span>
<span class="cm"> * peer.</span>
<span class="cm"> *</span>
<span class="cm"> * If both `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` return 0, the application should</span>
<span class="cm"> * drop the connection.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_want_write</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns stream_user_data for the stream |stream_id|.  The</span>
<span class="cm"> * stream_user_data is provided by `nghttp2_submit_request()`,</span>
<span class="cm"> * `nghttp2_submit_headers()` or</span>
<span class="cm"> * `nghttp2_session_set_stream_user_data()`.  Unless it is set using</span>
<span class="cm"> * `nghttp2_session_set_stream_user_data()`, if the stream is</span>
<span class="cm"> * initiated by the remote endpoint, stream_user_data is always</span>
<span class="cm"> * ``NULL``.  If the stream does not exist, this function returns</span>
<span class="cm"> * ``NULL``.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">nghttp2_session_get_stream_user_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                           <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the |stream_user_data| to the stream denoted by the</span>
<span class="cm"> * |stream_id|.  If a stream user data is already set to the stream,</span>
<span class="cm"> * it is replaced with the |stream_user_data|.  It is valid to specify</span>
<span class="cm"> * ``NULL`` in the |stream_user_data|, which nullifies the associated</span>
<span class="cm"> * data pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * It is valid to set the |stream_user_data| to the stream reserved by</span>
<span class="cm"> * PUSH_PROMISE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The stream does not exist</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_set_stream_user_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                         <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                         <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of frames in the outbound queue.  This does not</span>
<span class="cm"> * include the deferred DATA frames.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">nghttp2_session_get_outbound_queue_size</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of DATA payload in bytes received without</span>
<span class="cm"> * WINDOW_UPDATE transmission for the stream |stream_id|.  The local</span>
<span class="cm"> * (receive) window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective data length.  In particular, if the</span>
<span class="cm"> * local window size is reduced by submitting negative</span>
<span class="cm"> * window_size_increment with `nghttp2_submit_window_update()`, this</span>
<span class="cm"> * function returns the number of bytes less than actually received.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_effective_recv_data_length</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the local (receive) window size for the stream |stream_id|.</span>
<span class="cm"> * The local window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective window size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_effective_local_window_size</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of DATA payload in bytes received without</span>
<span class="cm"> * WINDOW_UPDATE transmission for a connection.  The local (receive)</span>
<span class="cm"> * window size can be adjusted by `nghttp2_submit_window_update()`.</span>
<span class="cm"> * This function takes into account that and returns effective data</span>
<span class="cm"> * length.  In particular, if the local window size is reduced by</span>
<span class="cm"> * submitting negative window_size_increment with</span>
<span class="cm"> * `nghttp2_submit_window_update()`, this function returns the number</span>
<span class="cm"> * of bytes less than actually received.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_effective_recv_data_length</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the local (receive) window size for a connection.  The</span>
<span class="cm"> * local window size can be adjusted by</span>
<span class="cm"> * `nghttp2_submit_window_update()`.  This function takes into account</span>
<span class="cm"> * that and returns effective window size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_effective_local_window_size</span>
<span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the remote window size for a given stream |stream_id|.</span>
<span class="cm"> * This is the amount of flow-controlled payload (e.g., DATA) that the</span>
<span class="cm"> * local endpoint can send without WINDOW_UPDATE.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns -1 if it fails.</span>
<span class="cm"> */</span>
<span class="kt">int32_t</span> <span class="nf">nghttp2_session_get_stream_remote_window_size</span><span class="p">(</span><span class="n">nghttp2_session</span><span class="o">*</span> <span class="n">session</span><span class="p">,</span>
                                                      <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Signals the session so that the connection should be terminated.</span>
<span class="cm"> *</span>
<span class="cm"> * GOAWAY frame with the given |error_code| will be submitted if it</span>
<span class="cm"> * has not been transmitted.  After the transmission, both</span>
<span class="cm"> * `nghttp2_session_want_read()` and `nghttp2_session_want_write()`</span>
<span class="cm"> * return 0.  If GOAWAY frame has already transmitted at the time when</span>
<span class="cm"> * this function is invoked, `nghttp2_session_want_read()` and</span>
<span class="cm"> * `nghttp2_session_want_write()` returns 0 immediately after this</span>
<span class="cm"> * function succeeds.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should be called when the connection should be</span>
<span class="cm"> * terminated after sending GOAWAY.  If the remaining streams should</span>
<span class="cm"> * be processed after GOAWAY, use `nghttp2_submit_goaway()` instead.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_terminate_session</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                                      <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Performs post-process of HTTP Upgrade request.  This function can</span>
<span class="cm"> * be called from both client and server, but the behavior is very</span>
<span class="cm"> * different in each other.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from client side, the |settings_payload| must be the</span>
<span class="cm"> * value sent in ``HTTP2-Settings`` header field and must be decoded</span>
<span class="cm"> * by base64url decoder.  The |settings_payloadlen| is the length of</span>
<span class="cm"> * |settings_payload|.  The |settings_payload| is unpacked and its</span>
<span class="cm"> * setting values will be submitted using `nghttp2_submit_settings()`.</span>
<span class="cm"> * This means that the client application code does not need to submit</span>
<span class="cm"> * SETTINGS by itself.  The stream with stream ID=1 is opened and the</span>
<span class="cm"> * |stream_user_data| is used for its stream_user_data.  The opened</span>
<span class="cm"> * stream becomes half-closed (local) state.</span>
<span class="cm"> *</span>
<span class="cm"> * If called from server side, the |settings_payload| must be the</span>
<span class="cm"> * value received in ``HTTP2-Settings`` header field and must be</span>
<span class="cm"> * decoded by base64url decoder.  The |settings_payloadlen| is the</span>
<span class="cm"> * length of |settings_payload|.  It is treated as if the SETTINGS</span>
<span class="cm"> * frame with that payload is received.  Thus, callback functions for</span>
<span class="cm"> * the reception of SETTINGS frame will be invoked.  The stream with</span>
<span class="cm"> * stream ID=1 is opened.  The |stream_user_data| is ignored.  The</span>
<span class="cm"> * opened stream becomes half-closed (remote).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |settings_payload| is badly formed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The stream ID 1 is already used or closed; or is not available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_session_upgrade</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                            <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">settings_payload</span><span class="p">,</span>
                            <span class="kt">size_t</span> <span class="n">settings_payloadlen</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Serializes the SETTINGS values |iv| in the |buf|.  The size of the</span>
<span class="cm"> * |buf| is specified by |buflen|.  The number of entries in the |iv|</span>
<span class="cm"> * array is given by |niv|.  The required space in |buf| for the |niv|</span>
<span class="cm"> * entries is ``8*niv`` bytes and if the given buffer is too small, an</span>
<span class="cm"> * error is returned.  This function is used mainly for creating a</span>
<span class="cm"> * SETTINGS payload to be sent with the ``HTTP2-Settings`` header</span>
<span class="cm"> * field in an HTTP Upgrade request.  The data written in |buf| is NOT</span>
<span class="cm"> * base64url encoded and the application is responsible for encoding.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of bytes written in |buf|, or one</span>
<span class="cm"> * of the following negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |iv| contains duplicate settings ID or invalid value.</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INSUFF_BUFSIZE`</span>
<span class="cm"> *     The provided |buflen| size is too small to hold the output.</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">nghttp2_pack_settings_payload</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="n">buflen</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
                                      <span class="kt">size_t</span> <span class="n">niv</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns string describing the |lib_error_code|.  The</span>
<span class="cm"> * |lib_error_code| must be one of the :enum:`nghttp2_error`.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">nghttp2_strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">lib_error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |pri_spec| with the |stream_id| of the stream to depend</span>
<span class="cm"> * on with |weight| and its exclusive flag.  If |exclusive| is</span>
<span class="cm"> * nonzero, exclusive flag is set.</span>
<span class="cm"> *</span>
<span class="cm"> * The |weight| must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_priority_spec_init</span><span class="p">(</span><span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
                                <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">weight</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">exclusive</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes |pri_spec| with the default values.  The default values</span>
<span class="cm"> * are: stream_id = 0, weight = :macro:`NGHTTP2_DEFAULT_WEIGHT` and</span>
<span class="cm"> * exclusive = 0.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_priority_spec_default_init</span><span class="p">(</span><span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if the |pri_spec| is filled with default values.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_priority_spec_check_default</span><span class="p">(</span><span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits HEADERS frame and optionally one or more DATA frames.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * means the default priority (see</span>
<span class="cm"> * `nghttp2_priority_spec_default_init()`).  To specify the priority,</span>
<span class="cm"> * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,</span>
<span class="cm"> * this function will copy its data members.</span>
<span class="cm"> *</span>
<span class="cm"> * The `pri_spec-&gt;weight` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If `pri_spec-&gt;weight` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The value is opaque sequence of bytes and</span>
<span class="cm"> * therefore can contain NULL byte (0x0).  If the application requires</span>
<span class="cm"> * that the ordering of values for a single header field name</span>
<span class="cm"> * appearing in different header fields, it has to concatenate them</span>
<span class="cm"> * using NULL byte (0x0) before passing them to this function.</span>
<span class="cm"> *</span>
<span class="cm"> * HTTP/2 specification has requirement about header fields in the</span>
<span class="cm"> * request HEADERS.  See the specification for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * If |data_prd| is not ``NULL``, it provides data which will be sent</span>
<span class="cm"> * in subsequent DATA frames.  In this case, a method that allows</span>
<span class="cm"> * request message bodies</span>
<span class="cm"> * (http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9) must</span>
<span class="cm"> * be specified with ``:method`` key in |nva| (e.g. ``POST``).  This</span>
<span class="cm"> * function does not take ownership of the |data_prd|.  The function</span>
<span class="cm"> * copies the members of the |data_prd|.  If |data_prd| is ``NULL``,</span>
<span class="cm"> * HEADERS have END_STREAM set.  The |stream_user_data| is data</span>
<span class="cm"> * associated to the stream opened by this request and can be an</span>
<span class="cm"> * arbitrary pointer, which can be retrieved later by</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()`.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the library reorders the frames and tries to send the highest</span>
<span class="cm"> * prioritized one first and the HTTP/2 specification requires the</span>
<span class="cm"> * stream ID must be strictly increasing, the stream ID of this</span>
<span class="cm"> * request cannot be known until it is about to sent.  To know the</span>
<span class="cm"> * stream ID of the request, the application can use</span>
<span class="cm"> * :member:`nghttp2_session_callbacks.before_frame_send_callback`.</span>
<span class="cm"> * This callback is called just before the frame is sent.  For HEADERS</span>
<span class="cm"> * frame, the argument frame has the stream ID assigned.  Also since</span>
<span class="cm"> * the stream is already opened,</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()` can be used to get</span>
<span class="cm"> * |stream_user_data| to identify which HEADERS we are processing.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_request</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">,</span>
                           <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits response HEADERS frame and optionally one or more DATA</span>
<span class="cm"> * frames against the stream |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The value is opaque sequence of bytes and</span>
<span class="cm"> * therefore can contain NULL byte (0x0).  If the application requires</span>
<span class="cm"> * that the ordering of values for a single header field name</span>
<span class="cm"> * appearing in different header fields, it has to concatenate them</span>
<span class="cm"> * using NULL byte (0x0) before passing them to this function.</span>
<span class="cm"> *</span>
<span class="cm"> * HTTP/2 specification has requirement about header fields in the</span>
<span class="cm"> * response HEADERS.  See the specification for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * If |data_prd| is not ``NULL``, it provides data which will be sent</span>
<span class="cm"> * in subsequent DATA frames.  This function does not take ownership</span>
<span class="cm"> * of the |data_prd|.  The function copies the members of the</span>
<span class="cm"> * |data_prd|.  If |data_prd| is ``NULL``, HEADERS will have</span>
<span class="cm"> * END_STREAM flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * This method can be used as normal HTTP response and push response.</span>
<span class="cm"> * When pushing a resource using this function, the |session| must be</span>
<span class="cm"> * configured using `nghttp2_session_server_new()` or its variants and</span>
<span class="cm"> * the target stream denoted by the |stream_id| must be reserved using</span>
<span class="cm"> * `nghttp2_submit_push_promise()`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_response</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span>
                            <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits HEADERS frame. The |flags| is bitwise OR of the</span>
<span class="cm"> * following values:</span>
<span class="cm"> *</span>
<span class="cm"> * * :enum:`NGHTTP2_FLAG_END_STREAM`</span>
<span class="cm"> *</span>
<span class="cm"> * If |flags| includes :enum:`NGHTTP2_FLAG_END_STREAM`, this frame has</span>
<span class="cm"> * END_STREAM flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * The library handles the CONTINUATION frame internally and it</span>
<span class="cm"> * correctly sets END_HEADERS to the last sequence of the PUSH_PROMISE</span>
<span class="cm"> * or CONTINUATION frame.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |stream_id| is -1, this frame is assumed as request (i.e.,</span>
<span class="cm"> * request HEADERS frame which opens new stream).  In this case, the</span>
<span class="cm"> * actual stream ID is assigned just before the frame is sent.  For</span>
<span class="cm"> * response, specify stream ID in |stream_id|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * means the default priority (see</span>
<span class="cm"> * `nghttp2_priority_spec_default_init()`).  To specify the priority,</span>
<span class="cm"> * use `nghttp2_priority_spec_init()`.  If |pri_spec| is not ``NULL``,</span>
<span class="cm"> * this function will copy its data members.</span>
<span class="cm"> *</span>
<span class="cm"> * The `pri_spec-&gt;weight` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If `pri_spec-&gt;weight` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The value is opaque sequence of bytes and</span>
<span class="cm"> * therefore can contain NULL byte (0x0).  If the application requires</span>
<span class="cm"> * that the ordering of values for a single header field name</span>
<span class="cm"> * appearing in different header fields, it has to concatenate them</span>
<span class="cm"> * using NULL byte (0x0) before passing them to this function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |stream_user_data| is a pointer to an arbitrary data which is</span>
<span class="cm"> * associated to the stream this frame will open.  Therefore it is</span>
<span class="cm"> * only used if this frame opens streams, in other words, it changes</span>
<span class="cm"> * stream state from idle or reserved to open.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is low-level in a sense that the application code can</span>
<span class="cm"> * specify flags directly.  For usual HTTP request,</span>
<span class="cm"> * `nghttp2_submit_request()` is useful.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_headers</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                           <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                           <span class="kt">void</span> <span class="o">*</span><span class="n">stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits one or more DATA frames to the stream |stream_id|.  The</span>
<span class="cm"> * data to be sent are provided by |data_prd|.  If |flags| contains</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_END_STREAM`, the last DATA frame has END_STREAM</span>
<span class="cm"> * flag set.  If |flags| contains :enum:`NGHTTP2_FLAG_END_SEGMENT`,</span>
<span class="cm"> * the last DATA frame has END_SEGMENT flag set.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership of the |data_prd|.  The</span>
<span class="cm"> * function copies the members of the |data_prd|.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_DATA_EXIST`</span>
<span class="cm"> *     DATA has been already submitted and not fully processed yet.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_data</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">nghttp2_data_provider</span> <span class="o">*</span><span class="n">data_prd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PRIORITY frame to change the priority of stream |stream_id|</span>
<span class="cm"> * to the priority specification |pri_spec|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |pri_spec| is priority specification of this request.  ``NULL``</span>
<span class="cm"> * is not allowed for this function. To specify the priority, use</span>
<span class="cm"> * `nghttp2_priority_spec_init()`.  This function will copy its data</span>
<span class="cm"> * members.</span>
<span class="cm"> *</span>
<span class="cm"> * The `pri_spec-&gt;weight` must be in [:enum:`NGHTTP2_MIN_WEIGHT`,</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`], inclusive.  If `pri_spec-&gt;weight` is</span>
<span class="cm"> * strictly less than :enum:`NGHTTP2_MIN_WEIGHT`, it becomes</span>
<span class="cm"> * :enum:`NGHTTP2_MIN_WEIGHT`.  If it is strictly greater than</span>
<span class="cm"> * :enum:`NGHTTP2_MAX_WEIGHT`, it becomes :enum:`NGHTTP2_MAX_WEIGHT`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |pri_spec| is NULL; or trying to depend on itself.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_priority</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                            <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_priority_spec</span> <span class="o">*</span><span class="n">pri_spec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits RST_STREAM frame to cancel/reject the stream |stream_id|</span>
<span class="cm"> * with the error code |error_code|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_rst_stream</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                              <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                              <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Stores local settings and submits SETTINGS frame.  The |iv| is the</span>
<span class="cm"> * pointer to the array of :type:`nghttp2_settings_entry`.  The |niv|</span>
<span class="cm"> * indicates the number of :type:`nghttp2_settings_entry`.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not take ownership of the |iv|.  This function</span>
<span class="cm"> * copies all the elements in the |iv|.</span>
<span class="cm"> *</span>
<span class="cm"> * While updating individual stream&#39;s local window size, if the window</span>
<span class="cm"> * size becomes strictly larger than NGHTTP2_MAX_WINDOW_SIZE,</span>
<span class="cm"> * RST_STREAM is issued against such a stream.</span>
<span class="cm"> *</span>
<span class="cm"> * SETTINGS with :enum:`NGHTTP2_FLAG_ACK` is automatically submitted</span>
<span class="cm"> * by the library and application could not send it at its will.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The |iv| contains invalid value (e.g., initial window size</span>
<span class="cm"> *     strictly greater than (1 &lt;&lt; 31) - 1.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS`</span>
<span class="cm"> *     There is already another in-flight SETTINGS.  Note that the</span>
<span class="cm"> *     current implementation only allows 1 in-flight SETTINGS frame</span>
<span class="cm"> *     without ACK flag set.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_settings</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">nghttp2_settings_entry</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">niv</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PUSH_PROMISE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored.  The library handles the</span>
<span class="cm"> * CONTINUATION frame internally and it correctly sets END_HEADERS to</span>
<span class="cm"> * the last sequence of the PUSH_PROMISE or CONTINUATION frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |stream_id| must be client initiated stream ID.</span>
<span class="cm"> *</span>
<span class="cm"> * The |nva| is an array of name/value pair :type:`nghttp2_nv` with</span>
<span class="cm"> * |nvlen| elements.  The value is opaque sequence of bytes and</span>
<span class="cm"> * therefore can contain NULL byte (0x0).  If the application requires</span>
<span class="cm"> * that the ordering of values for a single header field name</span>
<span class="cm"> * appearing in different header fields, it has to concatenate them</span>
<span class="cm"> * using NULL byte (0x0) before passing them to this function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates copies of all name/value pairs in |nva|.  It</span>
<span class="cm"> * also lower-cases all names in |nva|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |promised_stream_user_data| is a pointer to an arbitrary data</span>
<span class="cm"> * which is associated to the promised stream this frame will open and</span>
<span class="cm"> * make it in reserved state.  It is available using</span>
<span class="cm"> * `nghttp2_session_get_stream_user_data()`.  The application can</span>
<span class="cm"> * access it in :type:`nghttp2_before_frame_send_callback` and</span>
<span class="cm"> * :type:`nghttp2_on_frame_send_callback` of this frame.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the library reorders the frames and tries to send the highest</span>
<span class="cm"> * prioritized one first and the HTTP/2 specification requires the</span>
<span class="cm"> * stream ID must be strictly increasing, the promised stream ID</span>
<span class="cm"> * cannot be known until it is about to sent.  To know the promised</span>
<span class="cm"> * stream ID, the application can use</span>
<span class="cm"> * :member:`nghttp2_session_callbacks.before_frame_send_callback`.</span>
<span class="cm"> * This callback is called just before the frame is sent.  For</span>
<span class="cm"> * PUSH_PROMISE frame, the argument frame has the promised stream ID</span>
<span class="cm"> * assigned.</span>
<span class="cm"> *</span>
<span class="cm"> * The client side is not allowed to use this function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     This function was invoked when |session| is initialized as</span>
<span class="cm"> *     client.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_push_promise</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">nva</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nvlen</span><span class="p">,</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">promised_stream_user_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits PING frame.  You don&#39;t have to send PING back when you</span>
<span class="cm"> * received PING frame.  The library automatically submits PING frame</span>
<span class="cm"> * in this case.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |opaque_data| is non ``NULL``, then it should point to the 8</span>
<span class="cm"> * bytes array of memory to specify opaque data to send with PING</span>
<span class="cm"> * frame.  If the |opaque_data| is ``NULL``, zero-cleared 8 bytes will</span>
<span class="cm"> * be sent as opaque data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_ping</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits GOAWAY frame with the error code |error_code|.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |opaque_data| is not ``NULL`` and |opaque_data_len| is not</span>
<span class="cm"> * zero, those data will be sent as additional debug data.  The</span>
<span class="cm"> * library makes a copy of the memory region pointed by |opaque_data|</span>
<span class="cm"> * with the length |opaque_data_len|, so the caller does not need to</span>
<span class="cm"> * keep this memory after the return of this function.  If the</span>
<span class="cm"> * |opaque_data_len| is 0, the |opaque_data| could be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * NGHTTP2_ERR_INVALID_ARGUMENT</span>
<span class="cm"> *     The |opaque_data_len| is too large.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_goaway</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                          <span class="n">nghttp2_error_code</span> <span class="n">error_code</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">opaque_data_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits WINDOW_UPDATE frame.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is positive, the WINDOW_UPDATE with</span>
<span class="cm"> * that value as window_size_increment is queued.  If the</span>
<span class="cm"> * |window_size_increment| is larger than the received bytes from the</span>
<span class="cm"> * remote endpoint, the local window size is increased by that</span>
<span class="cm"> * difference.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is negative, the local window size</span>
<span class="cm"> * is decreased by -|window_size_increment|.  If</span>
<span class="cm"> * :enum:`NGHTTP2_OPT_NO_AUTO_STREAM_WINDOW_UPDATE` (or</span>
<span class="cm"> * :enum:`NGHTTP2_OPT_NO_AUTO_CONNECTION_WINDOW_UPDATE` if |stream_id|</span>
<span class="cm"> * is 0) is not set and the library decided that the WINDOW_UPDATE</span>
<span class="cm"> * should be submitted, then WINDOW_UPDATE is queued with the current</span>
<span class="cm"> * received bytes count.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |window_size_increment| is 0, the function does nothing and</span>
<span class="cm"> * returns 0.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_FLOW_CONTROL`</span>
<span class="cm"> *     The local window size overflow or gets negative.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_window_update</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                                 <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                                 <span class="kt">int32_t</span> <span class="n">window_size_increment</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Submits ALTSVC frame with given parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * The |flags| is currently ignored and should be</span>
<span class="cm"> * :enum:`NGHTTP2_FLAG_NONE`.</span>
<span class="cm"> *</span>
<span class="cm"> * Only the server can send the ALTSVC frame.  If |session| is</span>
<span class="cm"> * initialized as client, this function fails and returns</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_STATE`.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |protocol_id_len| is 0, the |protocol_id| could be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |host_len| is 0, the |host| could be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * If the |origin_len| is 0, the |origin| could be ``NULL``.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_PROTO`</span>
<span class="cm"> *     The function is invoked with |session| which was initialized as</span>
<span class="cm"> *     client.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_INVALID_ARGUMENT`</span>
<span class="cm"> *     The combined length of |protocol_id_len|, |host_len| and</span>
<span class="cm"> *     |origin_len| is is too large.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_submit_altsvc</span><span class="p">(</span><span class="n">nghttp2_session</span> <span class="o">*</span><span class="n">session</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">flags</span><span class="p">,</span>
                          <span class="kt">int32_t</span> <span class="n">stream_id</span><span class="p">,</span>
                          <span class="kt">uint32_t</span> <span class="n">max_age</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">protocol_id</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">protocol_id_len</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">host_len</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">origin_len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Compares ``lhs-&gt;name`` of length ``lhs-&gt;namelen`` bytes and</span>
<span class="cm"> * ``rhs-&gt;name`` of length ``rhs-&gt;namelen`` bytes.  Returns negative</span>
<span class="cm"> * integer if ``lhs-&gt;name`` is found to be less than ``rhs-&gt;name``; or</span>
<span class="cm"> * returns positive integer if ``lhs-&gt;name`` is found to be greater</span>
<span class="cm"> * than ``rhs-&gt;name``; or returns 0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_nv_compare_name</span><span class="p">(</span><span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">nghttp2_nv</span> <span class="o">*</span><span class="n">rhs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * A helper function for dealing with NPN in client side or ALPN in</span>
<span class="cm"> * server side.  The |in| contains peer&#39;s protocol list in preferable</span>
<span class="cm"> * order.  The format of |in| is length-prefixed and not</span>
<span class="cm"> * null-terminated.  For example, ``HTTP-draft-04/2.0`` and</span>
<span class="cm"> * ``http/1.1`` stored in |in| like this::</span>
<span class="cm"> *</span>
<span class="cm"> *     in[0] = 17</span>
<span class="cm"> *     in[1..17] = &quot;HTTP-draft-04/2.0&quot;</span>
<span class="cm"> *     in[18] = 8</span>
<span class="cm"> *     in[19..26] = &quot;http/1.1&quot;</span>
<span class="cm"> *     inlen = 27</span>
<span class="cm"> *</span>
<span class="cm"> * The selection algorithm is as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. If peer&#39;s list contains HTTP/2 protocol the library supports,</span>
<span class="cm"> *    it is selected and returns 1. The following step is not taken.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. If peer&#39;s list contains ``http/1.1``, this function selects</span>
<span class="cm"> *    ``http/1.1`` and returns 0.  The following step is not taken.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. This function selects nothing and returns -1 (So called</span>
<span class="cm"> *    non-overlap case).  In this case, |out| and |outlen| are left</span>
<span class="cm"> *    untouched.</span>
<span class="cm"> *</span>
<span class="cm"> * Selecting ``HTTP-draft-04/2.0`` means that ``HTTP-draft-04/2.0`` is</span>
<span class="cm"> * written into |*out| and its length (which is 17) is assigned to</span>
<span class="cm"> * |*outlen|.</span>
<span class="cm"> *</span>
<span class="cm"> * For ALPN, refer to</span>
<span class="cm"> * https://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg-05</span>
<span class="cm"> *</span>
<span class="cm"> * See http://technotes.googlecode.com/git/nextprotoneg.html for more</span>
<span class="cm"> * details about NPN.</span>
<span class="cm"> *</span>
<span class="cm"> * For NPN, to use this method you should do something like::</span>
<span class="cm"> *</span>
<span class="cm"> *     static int select_next_proto_cb(SSL* ssl,</span>
<span class="cm"> *                                     unsigned char **out,</span>
<span class="cm"> *                                     unsigned char *outlen,</span>
<span class="cm"> *                                     const unsigned char *in,</span>
<span class="cm"> *                                     unsigned int inlen,</span>
<span class="cm"> *                                     void *arg)</span>
<span class="cm"> *     {</span>
<span class="cm"> *         int rv;</span>
<span class="cm"> *         rv = nghttp2_select_next_protocol(out, outlen, in, inlen);</span>
<span class="cm"> *         if(rv == 1) {</span>
<span class="cm"> *             ((MyType*)arg)-&gt;http2_selected = 1;</span>
<span class="cm"> *         }</span>
<span class="cm"> *         return SSL_TLSEXT_ERR_OK;</span>
<span class="cm"> *     }</span>
<span class="cm"> *     ...</span>
<span class="cm"> *     SSL_CTX_set_next_proto_select_cb(ssl_ctx, select_next_proto_cb, my_obj);</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_select_next_protocol</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">outlen</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inlen</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">nghttp2_gzip</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @struct</span>
<span class="cm"> *</span>
<span class="cm"> * The gzip stream to inflate data.  The details of this structure are</span>
<span class="cm"> * intentionally hidden from the public API.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">nghttp2_gzip</span> <span class="n">nghttp2_gzip</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * A helper function to set up a per request gzip stream to inflate</span>
<span class="cm"> * data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_GZIP`</span>
<span class="cm"> *     The initialization of gzip stream failed.</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_NOMEM`</span>
<span class="cm"> *     Out of memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_gzip_inflate_new</span><span class="p">(</span><span class="n">nghttp2_gzip</span> <span class="o">**</span><span class="n">inflater_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Frees the inflate stream.  The |inflater| may be ``NULL``.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nghttp2_gzip_inflate_del</span><span class="p">(</span><span class="n">nghttp2_gzip</span> <span class="o">*</span><span class="n">inflater</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Inflates data in |in| with the length |*inlen_ptr| and stores the</span>
<span class="cm"> * inflated data to |out| which has allocated size at least</span>
<span class="cm"> * |*outlen_ptr|.  On return, |*outlen_ptr| is updated to represent</span>
<span class="cm"> * the number of data written in |out|.  Similarly, |*inlen_ptr| is</span>
<span class="cm"> * updated to represent the number of input bytes processed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if it succeeds, or one of the following</span>
<span class="cm"> * negative error codes:</span>
<span class="cm"> *</span>
<span class="cm"> * :enum:`NGHTTP2_ERR_GZIP`</span>
<span class="cm"> *     The inflation of gzip stream failed.</span>
<span class="cm"> *</span>
<span class="cm"> * The example follows::</span>
<span class="cm"> *</span>
<span class="cm"> *     void on_data_chunk_recv_callback(nghttp2_session *session,</span>
<span class="cm"> *                                      uint8_t flags,</span>
<span class="cm"> *                                      int32_t stream_id,</span>
<span class="cm"> *                                      const uint8_t *data, size_t len,</span>
<span class="cm"> *                                      void *user_data)</span>
<span class="cm"> *     {</span>
<span class="cm"> *         ...</span>
<span class="cm"> *         req = nghttp2_session_get_stream_user_data(session, stream_id);</span>
<span class="cm"> *         nghttp2_gzip *inflater = req-&gt;inflater;</span>
<span class="cm"> *         while(len &gt; 0) {</span>
<span class="cm"> *             uint8_t out[MAX_OUTLEN];</span>
<span class="cm"> *             size_t outlen = MAX_OUTLEN;</span>
<span class="cm"> *             size_t tlen = len;</span>
<span class="cm"> *             int rv;</span>
<span class="cm"> *             rv = nghttp2_gzip_inflate(inflater, out, &amp;outlen, data, &amp;tlen);</span>
<span class="cm"> *             if(rv != 0) {</span>
<span class="cm"> *                 nghttp2_submit_rst_stream(session, stream_id,</span>
<span class="cm"> *                                           NGHTTP2_INTERNAL_ERROR);</span>
<span class="cm"> *                 break;</span>
<span class="cm"> *             }</span>
<span class="cm"> *             ... Do stuff ...</span>
<span class="cm"> *             data += tlen;</span>
<span class="cm"> *             len -= tlen;</span>
<span class="cm"> *         }</span>
<span class="cm"> *         ....</span>
<span class="cm"> *     }</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_gzip_inflate</span><span class="p">(</span><span class="n">nghttp2_gzip</span> <span class="o">*</span><span class="n">inflater</span><span class="p">,</span>
                         <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">outlen_ptr</span><span class="p">,</span>
                         <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">inlen_ptr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to a nghttp2_info struct with version information</span>
<span class="cm"> * about the run-time library in use.  The |least_version| argument</span>
<span class="cm"> * can be set to a 24 bit numerical value for the least accepted</span>
<span class="cm"> * version number and if the condition is not met, this function will</span>
<span class="cm"> * return a ``NULL``.  Pass in 0 to skip the version checking.</span>
<span class="cm"> */</span>
<span class="n">nghttp2_info</span> <span class="o">*</span><span class="nf">nghttp2_version</span><span class="p">(</span><span class="kt">int</span> <span class="n">least_version</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if the :type:`nghttp2_error` library error code</span>
<span class="cm"> * |lib_error| is fatal.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_is_fatal</span><span class="p">(</span><span class="kt">int</span> <span class="n">lib_error</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if HTTP header field name |name| of length |len| is</span>
<span class="cm"> * valid according to</span>
<span class="cm"> * http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-25#section-3.2</span>
<span class="cm"> *</span>
<span class="cm"> * Because this is a header field name in HTTP2, the upper cased alphabet</span>
<span class="cm"> * is treated as error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_check_header_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * @function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns nonzero if HTTP header field value |value| of length |len|</span>
<span class="cm"> * is valid according to</span>
<span class="cm"> * http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-25#section-3.2</span>
<span class="cm"> *</span>
<span class="cm"> * Because this is HTTP2 header field value, it can contain NULL</span>
<span class="cm"> * character (0x00).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nghttp2_check_header_value</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* NGHTTP2_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nghttp2ver.h.html" class="btn btn-neutral float-right" title="nghttp2ver.h"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="apiref.html" class="btn btn-neutral" title="API Reference"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012, 2014, Tatsuhiro Tsujikawa.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>